---
layout: post
title: 从零开始学架构(极客时间)总结
description: 分享使用ipdb过程中的一些小tips
category: 技术
tags: [python]
---

# 17. 高性能缓存架构
## 正文
### 缓存的使用场景
+ 复杂运算比如count(*)，mysql每次都要计算的话很慢
+ 读多写少，我的理解是缓存主要是解决读的问题，比如首次访问从RDBMS写入数据到缓存，接下来的访问都走缓存

### 缓存穿透: 即没生效，穿透了缓存去查询数据库
+ 被访问数据不存在，解决方法是如果确实不存在，直接设置一个默认值作为key，下次访问缓存的时候就知道了
+ 生成缓存数据慢或消耗资源。比如爬虫会遍历不同的数据，没好办法，问题也不严重，还是从反爬虫入手。

### 缓存雪崩: 缓存过期重新生成的时间内收到大量请求
+ 更新锁: 只有一个线程可以更新缓存，其他的要不等待，要不返回默认值
+ 后台更新: 由后台定时更新，而不是由业务线程更新
+ 双key策略: key有失效时间，key1无，如果读取不到key就读取key1，并触发事件同时更新两个key

### 缓存热点: 对短时间内超高访问数据的解决方案
+ 复制多份副本，放到不同服务器
+ 注意不要设置同一个失效时间以免雪崩

## 其他
### mysql的缓存
+ 查询语句缓存: 如果查询缓存打开，mysql会优先查询是否命中查询缓存中的数据。但是条件苛刻不可控。
+ innodb buffer pool(没搞懂): 缓存的是磁盘上的分页数据，sql的执行还是省不了。

# 18. 单服务器高性能模式PPC与TPC

## 正文
### 高性能的要点
+ 高性能架构设计：决定上限
	+ 提高单服务器的性能
		+ 如何管理请求
		+ 如何处理请求
	+ 如果单服务器无法支撑，设计服务器集群
+ 具体代码实现: 决定下限

### PPC和TPC
+ PPC, process per connection，每次有新连接就新建一个进程，缺点是fork进程代价高
+ TPC, tread per connection, 每次有新连接就新建一个线程，创建线程代价低，但多线程可能会互相影响，导致死锁或单一线程崩溃导致进程崩溃
+ PPC有prefork, TPC有prethread，都是提前创建来解决新建消耗资源的问题。
+ PPC和TPC都是传统的单服务器高性能模式，最大连接数都是几百个，适用于常量而非海量连接数的场景

## 其他
#### 书
UNIX网络编程 三卷本

#### io之同步,异步,阻塞(bio),非阻塞(nio)
+ 同步异步: 关注的是消息通讯机制(synchronous/asynchronous communication)，即**被调用者是否会通知/回调**
	+ 同步指的是调用者主动等待被调用者返回结果
	+ 异步指的是调用发出后不等待结果直接返回，由被调用者告知结果或回调
+ 阻塞与非阻塞: 关注的是程序在等待调用结果（消息，返回值）时的状态，即**调用者在发起调用后是否还会干别的事**
	+ 阻塞调用是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回。PPC和TPC都属于这个.
	+ 非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程。

# 19. 单服务器高性能模式：Reactor与Proactor(未完成)
这一节没看懂，这俩应该属于io多路复用(io multiplexing)，而非作者说的nio
io多路复用应该和上面写的同步,异步,阻塞(bio),非阻塞(nio)是平行关系，但不确定
https://blog.csdn.net/mx472756841/article/details/70145762
https://segmentfault.com/a/1190000003063859
https://time.geekbang.org/column/article/8805

### Reactor
Reactor 模式的核心组成部分包括 Reactor 和处理资源池(进程池或线程池)

### 比方
Reactor与Proactor能不能这样打个比方：
1、假如我们去饭店点餐，饭店人很多，如果我们付了钱后站在收银台等着饭端上来我们才离开，这就成了同步阻塞了。
2、如果我们付了钱后给你一个号就可以离开，饭好了老板会叫号，你过来取。这就是Reactor模型。
3、如果我们付了钱后给我一个号就可以坐到坐位上该干啥干啥，饭好了老板会把饭端上来送给你。这就是Proactor模型了。

#20. 高性能集群负载均衡：分类及架构
### 复杂性
+ 增加一个任务分配器，也叫负载均衡器
+ 选择任务分配的算法

### 负载均衡分类
下面的123层可以依次一起用，组成了最强负载均衡，实际情况按日活到QPS，TPS来估算再进行设计

+ 第一层: DNS负载均衡，地理级别的均衡
	+ 缺点：
		+ 更新不及时，DNS缓存时间长
		+ 扩展性差，域名商控制
	+ 优点
		+ 简单便宜
		+ 就近访问提升速度
+ 第二层: 硬件负载均衡，比如F5,A10
	+ 缺点：
		+ 贵
		+ 扩展性差
	+ 优点:
		+ 功能强大，高性能(百万级)，高稳定，支持防火墙，防DDOS攻击
+ 第三层: 软件负载均衡，比如nginx(软件的7层负载均衡，万级), LVS(linux内核的4层负载均衡，十万级)
	+ 优缺点和硬件相反即是
	+ ps: 评论中有人提到nginx的新特性也能支持4层负载均衡，啥叫4层啥叫7层需要了解下

### 估算例子
1000wDAU => 平均每秒116 => QPS x10 => 高峰 x10 => 图片等静态资源x10(这一步可能夸张了？) 
=> 异地多活x2 => 半年增长x2 。即QPS=464000


#21. 高性能负载均衡算法
### 轮询/加权轮询
+ 优缺点都是简单，是最常用的算法，但无法感知服务器状态差异

### 负载最低优先(从服务端的角度)
+ LVS可根据连接数来判断服务器状态
+ nginx可根据http请求数(需扩展)
+ 自己开发可以看业务特点是IO密集还是CPU密集或其他。

### 性能最优：优先分配给响应时间低的(从客户款的角度)

### hash算法
根据ip地址或者sessionid或其他，确保同一个ip/session在同一个服务器上处理

#22. CAP理论
[Robert Greiner的blog](http://robertgreiner.com/2014/08/cap-theorem-revisited/)

在一个分布式系统(指互相连接并共享数据的节点集合)中，当涉及读写操作时，只能保证一致性（Consistence）、可用性（Available）、分区容错性（Partition Tolerence）三者中的两个，另外一个必须被牺牲.

+ 第二版强调了:
	+ 互相连接并共享数据: Memcache集群不是，而Mysql集群进行数据的复制，所以mysql集群是cap的讨论对象
	+ 读写: 比如zookeeper的选举就不是讨论对象
+ cap定义: (这个第二版的解释有点晦涩)
	+ 一致性: 对某个指定客户端来说，读操作保证返回最新的写操作数据
	+ 可用性：非故障节点在合理时间返回合理响应(非错误或超时)
	+ 分区容错性: 当出现网络分区后，系统能够继续“履行职责”。
+ cap应用(分布式环境，分区是必然现象，必须满足p)
	+ 也就是说在不同节点数据不一致的时候，要么等同步完成(**CP**)，要么返回旧的数据(**AP**)
+ 其他:
	+ Paxos属于CP，具体不懂，以后再补充










